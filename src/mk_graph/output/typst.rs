//! Typst output format for MIR visualization
//!
//! Generates .typ files that can be compiled to PDF with rich typography,
//! diagrams, and structured layout.

use std::fs::File;
use std::io::{self, BufWriter, Write};

extern crate rustc_middle;
use rustc_middle::ty::TyCtxt;

extern crate rustc_session;
use rustc_session::config::{OutFileName, OutputType};

use crate::printer::{collect_smir, SmirJson};
use crate::render::short_fn_name;
use crate::MonoItemKind;

use super::traversal::{BlockRole, FunctionContext, SpanIndex, TypeIndex};

/// Entry point to generate Typst file
pub fn emit_typstfile(tcx: TyCtxt<'_>) {
    let smir = collect_smir(tcx);
    let typst = generate_typst(&smir);

    match tcx.output_filenames(()).path(OutputType::Mir) {
        OutFileName::Stdout => {
            write!(io::stdout(), "{}", typst).expect("Failed to write Typst");
        }
        OutFileName::Real(path) => {
            let out_path = path.with_extension("smir.typ");
            let mut b = BufWriter::new(
                File::create(&out_path)
                    .unwrap_or_else(|e| panic!("Failed to create {}: {}", out_path.display(), e)),
            );
            write!(b, "{}", typst).expect("Failed to write Typst");
        }
    }
}

/// Generate the complete Typst document
fn generate_typst(smir: &SmirJson) -> String {
    let mut content = String::new();

    // Preamble
    content.push_str(&generate_preamble());

    // Build indices for lookups
    let span_index = SpanIndex::from_spans(&smir.spans);
    let type_index = TypeIndex::from_types(&smir.types);

    // Generate content for each function
    for item in &smir.items {
        let MonoItemKind::MonoItemFn { name, body, .. } = &item.mono_item_kind else {
            continue;
        };

        let Some(body) = body else { continue };

        // Skip standard library functions for cleaner output
        if name.contains("std::") || name.contains("core::") {
            continue;
        }

        let short_name = short_fn_name(name);
        let ctx = FunctionContext::new(&short_name, name, body, &span_index, &type_index);
        content.push_str(&generate_function_typst(&ctx));
    }

    content
}

/// Generate Typst preamble with imports and styling
fn generate_preamble() -> String {
    r#"// MIR Walkthrough - Generated by stable-mir-json

#set document(title: "MIR Walkthrough")
#set page(margin: 2cm, numbering: "1")
#set text(font: "New Computer Modern", size: 10pt)
#set heading(numbering: "1.1")
#set par(justify: true)

#show raw.where(block: true): block.with(
  fill: luma(245),
  inset: 8pt,
  radius: 4pt,
  width: 100%,
)

#show table.cell.where(y: 0): strong

"#
    .to_string()
}

/// Generate Typst for a single function
fn generate_function_typst(ctx: &FunctionContext) -> String {
    let mut typ = String::new();

    // === Header ===
    typ.push_str(&format!("= `{}` — MIR Walkthrough\n\n", ctx.short_name));

    // Purpose placeholder
    typ.push_str("#block(fill: luma(250), inset: 12pt, radius: 4pt, width: 100%)[\n");
    typ.push_str(
        "  *Purpose:* #text(fill: rgb(\"#999999\"))[TODO: Describe why this walkthrough exists]\n",
    );
    typ.push_str("]\n\n");

    // === Source Context ===
    typ.push_str("== Source Context\n\n");
    if let Some(source) = &ctx.source {
        typ.push_str("```rust\n");
        typ.push_str(source);
        typ.push_str("\n```\n\n");
    } else {
        typ.push_str("_Source not available_\n\n");
    }

    // === Function Overview ===
    typ.push_str("== Function Overview\n\n");
    typ.push_str(&format!("- *Function:* `{}`\n", ctx.short_name));
    typ.push_str(&format!("- *Basic blocks:* {}\n", ctx.body.blocks.len()));

    if let Some((_, decl)) = ctx.body.local_decls().next() {
        typ.push_str(&format!(
            "- *Return type:* `{}`\n",
            ctx.render_type(decl.ty)
        ));
    }

    let prop_list = ctx.property_strings();
    if !prop_list.is_empty() {
        typ.push_str("- *Notable properties:*\n");
        for prop in prop_list {
            typ.push_str(&format!("  - {}\n", prop));
        }
    }
    typ.push_str("\n");

    // === Locals ===
    typ.push_str("== Locals\n\n");
    typ.push_str("#table(\n");
    typ.push_str("  columns: (auto, 1fr, auto),\n");
    typ.push_str("  align: (center, left, left),\n");
    typ.push_str("  [*Local*], [*Type*], [*Notes*],\n");

    for (i, (index, decl)) in ctx.body.local_decls().enumerate() {
        let note = if i == 0 { "Return place" } else { "" };
        typ.push_str(&format!(
            "  [`{}`], [`{}`], [{}],\n",
            index,
            escape_typst_code(&ctx.render_type(decl.ty)),
            note
        ));
    }
    typ.push_str(")\n\n");

    // === Borrows ===
    if ctx.has_borrows() {
        typ.push_str("== Borrows\n\n");
        typ.push_str("#table(\n");
        typ.push_str("  columns: (auto, auto, auto, auto, auto),\n");
        typ.push_str("  align: (center, center, center, center, center),\n");
        typ.push_str("  [*\\#*], [*Borrow*], [*Kind*], [*Created At*], [*Borrowed*],\n");

        for borrow in ctx.borrows() {
            let kind = match borrow.kind {
                super::traversal::BorrowKindInfo::Shared => "`&`",
                super::traversal::BorrowKindInfo::Mutable => "`&mut`",
                super::traversal::BorrowKindInfo::Shallow => "`&shallow`",
            };
            typ.push_str(&format!(
                "  [{}], [`_{}`], [{}], [`bb{}[{}]`], [`_{}`],\n",
                borrow.index,
                borrow.borrower_local,
                kind,
                borrow.start_location.block,
                borrow.start_location.statement,
                borrow.borrowed_local
            ));
        }
        typ.push_str(")\n\n");
        typ.push_str("#text(size: 9pt, fill: rgb(\"#666666\"))[\n");
        typ.push_str("  _Borrows are tracked conservatively: active from creation until reassignment or scope end._\n");
        typ.push_str("]\n\n");
    }

    // === Control-Flow Diagram ===
    typ.push_str("== Control-Flow Overview\n\n");
    typ.push_str(&ctx.typst_cfg());
    typ.push_str("\n");

    // === Basic Blocks ===
    typ.push_str("== Basic Blocks\n\n");
    for idx in 0..ctx.body.blocks.len() {
        let role = ctx.block_role(idx);
        let rows = ctx.render_block(idx);
        typ.push_str(&render_block_typst(idx, &rows, role));
    }

    // Key Observations placeholder
    typ.push_str("== Key Observations\n\n");
    typ.push_str("#block(fill: luma(250), inset: 12pt, radius: 4pt, width: 100%)[\n");
    typ.push_str("  #text(fill: rgb(\"#999999\"))[TODO: Add bullet points summarizing what this MIR teaches]\n");
    typ.push_str("  \n");
    typ.push_str("  - \n");
    typ.push_str("  - \n");
    typ.push_str("]\n\n");

    // Takeaways placeholder
    typ.push_str("== Takeaways\n\n");
    typ.push_str("#block(fill: luma(250), inset: 12pt, radius: 4pt, width: 100%)[\n");
    typ.push_str(
        "  #text(fill: rgb(\"#999999\"))[TODO: One or two sentences to generalize this example]\n",
    );
    typ.push_str("]\n\n");

    typ.push_str("#pagebreak()\n\n");

    typ
}

/// Render a basic block as Typst content
fn render_block_typst(
    idx: usize,
    rows: &[super::traversal::AnnotatedRow],
    role: BlockRole,
) -> String {
    let mut typ = String::new();

    let role_str = role.title();
    typ.push_str(&format!("=== bb{}", idx));
    if !role_str.is_empty() {
        typ.push_str(&format!(
            " #text(fill: rgb(\"#888888\"), weight: \"regular\")[ — {}]",
            role_str
        ));
    }
    typ.push_str("\n\n");

    // Role description
    match role {
        BlockRole::Entry => typ.push_str("_Entry point of the function._\n\n"),
        BlockRole::Return => typ.push_str("_Normal return path._\n\n"),
        BlockRole::Panic => typ.push_str("_Panic/diverging path._\n\n"),
        BlockRole::Cleanup => typ.push_str("_Unwinding cleanup handler._\n\n"),
        _ => {}
    }

    // Table of statements and terminator
    typ.push_str("#table(\n");
    typ.push_str("  columns: (1fr, 1fr),\n");
    typ.push_str("  align: (left, left),\n");
    typ.push_str("  [*MIR*], [*Annotation*],\n");

    for row in rows {
        let mir = if row.is_terminator {
            format!("→ {}", row.mir)
        } else {
            row.mir.clone()
        };
        typ.push_str(&format!(
            "  [`{}`], [{}],\n",
            escape_typst_code(&mir),
            escape_typst(&row.annotation)
        ));
    }

    typ.push_str(")\n\n");

    typ
}

/// Escape for content inside backticks (raw/code mode)
/// Only backticks need escaping in raw mode
fn escape_typst_code(s: &str) -> String {
    s.replace('`', "'")
}

/// Escape special Typst characters for plain text
fn escape_typst(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('#', "\\#")
        .replace('$', "\\$")
        .replace('@', "\\@")
        .replace('<', "\\<")
        .replace('>', "\\>")
        .replace('[', "\\[")
        .replace(']', "\\]")
        .replace('_', "\\_")
        .replace('*', "\\*")
}
