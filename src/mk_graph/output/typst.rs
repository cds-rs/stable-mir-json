//! Typst output format for MIR visualization
//!
//! Generates .typ files that can be compiled to PDF with rich typography,
//! diagrams, and structured layout.

use std::collections::{HashMap, HashSet};
use std::fs::File;
use std::io::{self, BufWriter, Write};

extern crate rustc_middle;
use rustc_middle::ty::TyCtxt;

extern crate rustc_session;
use rustc_session::config::{OutFileName, OutputType};

extern crate stable_mir;
use stable_mir::mir::{
    BasicBlock, Body, Rvalue, Statement, StatementKind, Terminator, TerminatorKind, UnwindAction,
};
use stable_mir::ty::IndexedVal;

use crate::printer::{collect_smir, SmirJson};
use crate::render::{
    annotate_rvalue, extract_call_name, render_operand, render_place, render_rvalue, short_fn_name,
};
use crate::MonoItemKind;

/// Span information: (filename, start_line, start_col, end_line, end_col)
type SpanInfo = (String, usize, usize, usize, usize);

/// Detected properties of a function
#[derive(Default)]
struct FunctionProperties {
    has_panic_path: bool,
    has_checked_ops: bool,
    has_borrows: bool,
    has_drops: bool,
    has_recursion: bool,
    has_assertions: bool,
    has_switches: bool,
}

/// Inferred role of a basic block
#[derive(Clone, Copy, PartialEq)]
enum BlockRole {
    Entry,
    Return,
    Panic,
    Cleanup,
    Branch,
    Loop,
    Normal,
}

impl BlockRole {
    fn title(&self) -> &'static str {
        match self {
            BlockRole::Entry => "entry",
            BlockRole::Return => "return / success",
            BlockRole::Panic => "panic path",
            BlockRole::Cleanup => "cleanup / unwind",
            BlockRole::Branch => "branch point",
            BlockRole::Loop => "loop",
            BlockRole::Normal => "",
        }
    }
}

/// Entry point to generate Typst file
pub fn emit_typstfile(tcx: TyCtxt<'_>) {
    let smir = collect_smir(tcx);
    let typst = generate_typst(&smir);

    match tcx.output_filenames(()).path(OutputType::Mir) {
        OutFileName::Stdout => {
            write!(io::stdout(), "{}", typst).expect("Failed to write Typst");
        }
        OutFileName::Real(path) => {
            let out_path = path.with_extension("smir.typ");
            let mut b = BufWriter::new(
                File::create(&out_path)
                    .unwrap_or_else(|e| panic!("Failed to create {}: {}", out_path.display(), e)),
            );
            write!(b, "{}", typst).expect("Failed to write Typst");
        }
    }
}

/// Generate the complete Typst document
fn generate_typst(smir: &SmirJson) -> String {
    let mut content = String::new();

    // Preamble
    content.push_str(&generate_preamble());

    // Build span index for source lookups
    let span_index: HashMap<usize, &SpanInfo> =
        smir.spans.iter().map(|(id, info)| (*id, info)).collect();

    // Generate content for each function
    for item in &smir.items {
        let MonoItemKind::MonoItemFn { name, body, .. } = &item.mono_item_kind else {
            continue;
        };

        let Some(body) = body else { continue };

        // Skip standard library functions for cleaner output
        if name.contains("std::") || name.contains("core::") {
            continue;
        }

        let short_name = short_fn_name(name);
        content.push_str(&generate_function_typst(&short_name, name, body, &span_index));
    }

    content
}

/// Generate Typst preamble with imports and styling
fn generate_preamble() -> String {
    r#"// MIR Walkthrough - Generated by stable-mir-json

#set document(title: "MIR Walkthrough")
#set page(margin: 2cm, numbering: "1")
#set text(font: "New Computer Modern", size: 10pt)
#set heading(numbering: "1.1")
#set par(justify: true)

#show raw.where(block: true): block.with(
  fill: luma(245),
  inset: 8pt,
  radius: 4pt,
  width: 100%,
)

#show table.cell.where(y: 0): strong

"#
    .to_string()
}

/// Generate Typst for a single function
fn generate_function_typst(
    short_name: &str,
    _full_name: &str,
    body: &Body,
    span_index: &HashMap<usize, &SpanInfo>,
) -> String {
    let mut typ = String::new();

    // Analyze the function
    let properties = analyze_function(body, short_name);
    let block_roles = infer_block_roles(body);

    // === Header ===
    typ.push_str(&format!("= `{}` — MIR Walkthrough\n\n", short_name));

    // Purpose placeholder
    typ.push_str("#block(fill: luma(250), inset: 12pt, radius: 4pt, width: 100%)[\n");
    typ.push_str("  *Purpose:* #text(fill: rgb(\"#999999\"))[TODO: Describe why this walkthrough exists]\n");
    typ.push_str("]\n\n");

    // === Source Context ===
    typ.push_str("== Source Context\n\n");
    if let Some(source) = extract_function_source(span_index, body) {
        typ.push_str("```rust\n");
        typ.push_str(&source);
        typ.push_str("\n```\n\n");
    } else {
        typ.push_str("_Source not available_\n\n");
    }

    // === Function Overview ===
    typ.push_str("== Function Overview\n\n");
    typ.push_str(&format!("- *Function:* `{}`\n", short_name));
    typ.push_str(&format!("- *Basic blocks:* {}\n", body.blocks.len()));

    if let Some((_, decl)) = body.local_decls().next() {
        typ.push_str(&format!("- *Return type:* `{}`\n", decl.ty));
    }

    let prop_list = format_properties(&properties);
    if !prop_list.is_empty() {
        typ.push_str("- *Notable properties:*\n");
        for prop in prop_list {
            typ.push_str(&format!("  - {}\n", prop));
        }
    }
    typ.push_str("\n");

    // === Locals ===
    typ.push_str("== Locals\n\n");
    typ.push_str("#table(\n");
    typ.push_str("  columns: (auto, 1fr, auto),\n");
    typ.push_str("  align: (center, left, left),\n");
    typ.push_str("  [*Local*], [*Type*], [*Notes*],\n");

    for (i, (index, decl)) in body.local_decls().enumerate() {
        let note = if i == 0 { "Return place" } else { "" };
        typ.push_str(&format!(
            "  [`{}`], [`{}`], [{}],\n",
            index,
            escape_typst(&format!("{}", decl.ty)),
            note
        ));
    }
    typ.push_str(")\n\n");

    // === Control-Flow Diagram ===
    typ.push_str("== Control-Flow Overview\n\n");
    typ.push_str(&generate_cfg_diagram(body, &block_roles));
    typ.push_str("\n");

    // === Basic Blocks ===
    typ.push_str("== Basic Blocks\n\n");
    for (idx, block) in body.blocks.iter().enumerate() {
        let role = block_roles.get(&idx).copied().unwrap_or(BlockRole::Normal);
        typ.push_str(&render_block_typst(idx, block, role, short_name));
    }

    // Key Observations placeholder
    typ.push_str("== Key Observations\n\n");
    typ.push_str("#block(fill: luma(250), inset: 12pt, radius: 4pt, width: 100%)[\n");
    typ.push_str("  #text(fill: rgb(\"#999999\"))[TODO: Add bullet points summarizing what this MIR teaches]\n");
    typ.push_str("  \n");
    typ.push_str("  - \n");
    typ.push_str("  - \n");
    typ.push_str("]\n\n");

    // Takeaways placeholder
    typ.push_str("== Takeaways\n\n");
    typ.push_str("#block(fill: luma(250), inset: 12pt, radius: 4pt, width: 100%)[\n");
    typ.push_str("  #text(fill: rgb(\"#999999\"))[TODO: One or two sentences to generalize this example]\n");
    typ.push_str("]\n\n");

    typ.push_str("#pagebreak()\n\n");

    typ
}

/// Generate ASCII control-flow diagram (similar to markdown)
fn generate_cfg_diagram(body: &Body, roles: &HashMap<usize, BlockRole>) -> String {
    let mut typ = String::new();

    typ.push_str("```\n");

    for (idx, block) in body.blocks.iter().enumerate() {
        let role = roles.get(&idx).copied().unwrap_or(BlockRole::Normal);
        let role_suffix = match role {
            BlockRole::Entry => " (entry)",
            BlockRole::Return => " (return)",
            BlockRole::Panic => " (panic)",
            BlockRole::Cleanup => " (cleanup)",
            BlockRole::Branch => " (branch)",
            BlockRole::Loop => " (loop)",
            BlockRole::Normal => "",
        };

        let targets = get_terminator_targets(&block.terminator);
        if targets.is_empty() {
            typ.push_str(&format!("bb{}{}\n", idx, role_suffix));
        } else {
            let arrows: Vec<String> = targets.iter().map(|t| format!("bb{}", t)).collect();
            typ.push_str(&format!("bb{}{} ──▶ {}\n", idx, role_suffix, arrows.join(", ")));
        }
    }

    typ.push_str("```\n");

    typ
}

/// Render a basic block as Typst content
fn render_block_typst(idx: usize, block: &BasicBlock, role: BlockRole, current_fn: &str) -> String {
    let mut typ = String::new();

    let role_str = role.title();
    typ.push_str(&format!("=== bb{}", idx));
    if !role_str.is_empty() {
        typ.push_str(&format!(
            " #text(fill: rgb(\"#888888\"), weight: \"regular\")[ — {}]",
            role_str
        ));
    }
    typ.push_str("\n\n");

    // Role description
    match role {
        BlockRole::Entry => typ.push_str("_Entry point of the function._\n\n"),
        BlockRole::Return => typ.push_str("_Normal return path._\n\n"),
        BlockRole::Panic => typ.push_str("_Panic/diverging path._\n\n"),
        BlockRole::Cleanup => typ.push_str("_Unwinding cleanup handler._\n\n"),
        _ => {}
    }

    // Table of statements and terminator
    typ.push_str("#table(\n");
    typ.push_str("  columns: (1fr, 1fr),\n");
    typ.push_str("  align: (left, left),\n");
    typ.push_str("  [*MIR*], [*Annotation*],\n");

    // Statements
    for stmt in &block.statements {
        let (mir, annotation) = render_statement_annotated(stmt);
        typ.push_str(&format!(
            "  [`{}`], [{}],\n",
            escape_typst(&mir),
            escape_typst(&annotation)
        ));
    }

    // Terminator
    let (mir, annotation, _) = render_terminator_annotated(&block.terminator, current_fn);
    typ.push_str(&format!(
        "  [`→ {}`], [{}],\n",
        escape_typst(&mir),
        escape_typst(&annotation)
    ));

    typ.push_str(")\n\n");

    typ
}

/// Analyze function to detect notable properties
fn analyze_function(body: &Body, fn_name: &str) -> FunctionProperties {
    let mut props = FunctionProperties::default();

    for block in &body.blocks {
        for stmt in &block.statements {
            if let StatementKind::Assign(_, rvalue) = &stmt.kind {
                match rvalue {
                    Rvalue::CheckedBinaryOp(..) => props.has_checked_ops = true,
                    Rvalue::Ref(..) => props.has_borrows = true,
                    _ => {}
                }
            }
        }

        match &block.terminator.kind {
            TerminatorKind::Call { func, .. } => {
                let call_name = extract_call_name(func);
                if call_name.contains("panic") {
                    props.has_panic_path = true;
                }
                if call_name == fn_name {
                    props.has_recursion = true;
                }
            }
            TerminatorKind::Assert { .. } => {
                props.has_assertions = true;
                props.has_panic_path = true;
            }
            TerminatorKind::SwitchInt { .. } => props.has_switches = true,
            TerminatorKind::Drop { .. } => props.has_drops = true,
            TerminatorKind::Unreachable {} => props.has_panic_path = true,
            _ => {}
        }
    }

    props
}

/// Format properties as list of strings
fn format_properties(props: &FunctionProperties) -> Vec<&'static str> {
    let mut list = Vec::new();
    if props.has_panic_path {
        list.push("Contains panic path");
    }
    if props.has_checked_ops {
        list.push("Uses checked arithmetic");
    }
    if props.has_borrows {
        list.push("Contains borrows");
    }
    if props.has_drops {
        list.push("Has explicit drops");
    }
    if props.has_recursion {
        list.push("Recursive");
    }
    if props.has_assertions {
        list.push("Contains assertions");
    }
    if props.has_switches {
        list.push("Has conditional branches");
    }
    list
}

/// Infer roles for each block
fn infer_block_roles(body: &Body) -> HashMap<usize, BlockRole> {
    let mut roles = HashMap::new();

    // First pass: identify entry block
    roles.insert(0, BlockRole::Entry);

    // Identify cleanup blocks
    let mut cleanup_blocks = HashSet::new();
    for block in &body.blocks {
        let unwind = match &block.terminator.kind {
            TerminatorKind::Drop { unwind, .. } => Some(unwind),
            TerminatorKind::Call { unwind, .. } => Some(unwind),
            TerminatorKind::Assert { unwind, .. } => Some(unwind),
            _ => None,
        };
        if let Some(UnwindAction::Cleanup(target)) = unwind {
            cleanup_blocks.insert(*target);
        }
    }

    // Detect loops
    let loop_blocks = detect_loops(body);

    for (idx, block) in body.blocks.iter().enumerate() {
        if roles.contains_key(&idx) {
            continue;
        }

        if cleanup_blocks.contains(&idx) {
            roles.insert(idx, BlockRole::Cleanup);
            continue;
        }

        if loop_blocks.contains(&idx) {
            roles.insert(idx, BlockRole::Loop);
            continue;
        }

        match &block.terminator.kind {
            TerminatorKind::Return {} => {
                roles.insert(idx, BlockRole::Return);
            }
            TerminatorKind::Resume {} | TerminatorKind::Abort {} | TerminatorKind::Unreachable {} => {
                roles.insert(idx, BlockRole::Panic);
            }
            TerminatorKind::Call { target: None, .. } => {
                roles.insert(idx, BlockRole::Panic);
            }
            TerminatorKind::Call { func, .. } => {
                let name = extract_call_name(func);
                if name.contains("panic") || name.contains("assert_failed") {
                    roles.insert(idx, BlockRole::Panic);
                }
            }
            TerminatorKind::SwitchInt { .. } => {
                roles.insert(idx, BlockRole::Branch);
            }
            _ => {}
        }
    }

    roles
}

/// Detect blocks that are part of loops
fn detect_loops(body: &Body) -> HashSet<usize> {
    let mut loop_blocks = HashSet::new();

    let successors: Vec<Vec<usize>> = body
        .blocks
        .iter()
        .map(|b| get_terminator_targets(&b.terminator))
        .collect();

    for start in 0..body.blocks.len() {
        let mut visited = HashSet::new();
        let mut stack = successors[start].clone();

        while let Some(curr) = stack.pop() {
            if curr == start {
                loop_blocks.insert(start);
                break;
            }
            if visited.insert(curr) && curr < successors.len() {
                stack.extend(successors[curr].iter().copied());
            }
        }
    }

    loop_blocks
}

/// Get target block indices from a terminator
fn get_terminator_targets(term: &Terminator) -> Vec<usize> {
    match &term.kind {
        TerminatorKind::Goto { target } => vec![*target],
        TerminatorKind::SwitchInt { targets, .. } => {
            let mut result: Vec<usize> = targets.branches().map(|(_, t)| t).collect();
            result.push(targets.otherwise());
            result
        }
        TerminatorKind::Return {}
        | TerminatorKind::Resume {}
        | TerminatorKind::Abort {}
        | TerminatorKind::Unreachable {} => vec![],
        TerminatorKind::Drop { target, unwind, .. } => {
            let mut result = vec![*target];
            if let UnwindAction::Cleanup(t) = unwind {
                result.push(*t);
            }
            result
        }
        TerminatorKind::Call { target, unwind, .. } => {
            let mut result = vec![];
            if let Some(t) = target {
                result.push(*t);
            }
            if let UnwindAction::Cleanup(t) = unwind {
                result.push(*t);
            }
            result
        }
        TerminatorKind::Assert { target, unwind, .. } => {
            let mut result = vec![*target];
            if let UnwindAction::Cleanup(t) = unwind {
                result.push(*t);
            }
            result
        }
        TerminatorKind::InlineAsm {
            destination,
            unwind,
            ..
        } => {
            let mut result = vec![];
            if let Some(t) = destination {
                result.push(*t);
            }
            if let UnwindAction::Cleanup(t) = unwind {
                result.push(*t);
            }
            result
        }
    }
}

/// Render a statement with annotation
fn render_statement_annotated(stmt: &Statement) -> (String, String) {
    match &stmt.kind {
        StatementKind::Assign(place, rvalue) => {
            let mir = format!("{} = {}", render_place(place), render_rvalue(rvalue));
            let annotation = annotate_rvalue(rvalue);
            (mir, annotation)
        }
        StatementKind::SetDiscriminant {
            place,
            variant_index,
        } => (
            format!(
                "discr({}) = {}",
                render_place(place),
                variant_index.to_index()
            ),
            "Set enum discriminant".to_string(),
        ),
        StatementKind::StorageLive(local) => (
            format!("StorageLive({})", local),
            "Allocate local storage".to_string(),
        ),
        StatementKind::StorageDead(local) => (
            format!("StorageDead({})", local),
            "Deallocate local storage".to_string(),
        ),
        StatementKind::PlaceMention(place) => (
            format!("PlaceMention({})", render_place(place)),
            "Compiler hint for borrow checker".to_string(),
        ),
        _ => (format!("{:?}", stmt.kind), String::new()),
    }
}

/// Render a terminator with annotation
fn render_terminator_annotated(term: &Terminator, current_fn: &str) -> (String, String, bool) {
    match &term.kind {
        TerminatorKind::Goto { target } => (
            format!("goto bb{}", target),
            format!("Jump to bb{}", target),
            false,
        ),
        TerminatorKind::Return {} => (
            "return".to_string(),
            "Return from function".to_string(),
            false,
        ),
        TerminatorKind::Unreachable {} => (
            "unreachable".to_string(),
            "Unreachable code".to_string(),
            false,
        ),
        TerminatorKind::SwitchInt { discr, targets } => {
            let discr_str = render_operand(discr);
            let branches: Vec<String> = targets
                .branches()
                .map(|(val, bb)| format!("{}→bb{}", val, bb))
                .collect();
            let otherwise = targets.otherwise();
            let mir = format!(
                "switch({}) [{}; else→bb{}]",
                discr_str,
                branches.join(", "),
                otherwise
            );
            let annotation = format!("Branch on {}", discr_str);
            (mir, annotation, false)
        }
        TerminatorKind::Call {
            func,
            args,
            destination,
            target,
            ..
        } => {
            let func_name = extract_call_name(func);
            let args_str: Vec<String> = args.iter().map(|a| render_operand(&a.clone())).collect();
            let dest = render_place(destination);
            let target_str = target.map(|t| format!(" → bb{}", t)).unwrap_or_default();
            let mir = format!("{} = {}({}){}", dest, func_name, args_str.join(", "), target_str);

            let is_recursive = func_name == current_fn;
            let annotation = if is_recursive {
                format!("Recursive call to {}", func_name)
            } else {
                format!("Call {}", func_name)
            };
            (mir, annotation, is_recursive)
        }
        TerminatorKind::Assert {
            cond,
            expected,
            target,
            ..
        } => {
            let cond_str = render_operand(cond);
            let mir = format!("assert({} == {}) → bb{}", cond_str, expected, target);
            let annotation = if *expected {
                format!("Panic if {} is false", cond_str)
            } else {
                format!("Panic if {} is true", cond_str)
            };
            (mir, annotation, false)
        }
        TerminatorKind::Drop { place, target, .. } => (
            format!("drop({}) → bb{}", render_place(place), target),
            "Drop value".to_string(),
            false,
        ),
        TerminatorKind::Resume {} => (
            "resume".to_string(),
            "Resume unwinding".to_string(),
            false,
        ),
        TerminatorKind::Abort {} => ("abort".to_string(), "Abort execution".to_string(), false),
        _ => (format!("{:?}", term.kind), String::new(), false),
    }
}

/// Extract function source from spans
fn extract_function_source(
    span_index: &HashMap<usize, &SpanInfo>,
    body: &Body,
) -> Option<String> {
    let first_span = if !body.blocks.is_empty() {
        let block = &body.blocks[0];
        if !block.statements.is_empty() {
            Some(block.statements[0].span.to_index())
        } else {
            Some(block.terminator.span.to_index())
        }
    } else {
        None
    };

    let span_info = first_span.and_then(|idx| span_index.get(&idx).copied())?;
    let file = &span_info.0;

    let mut min_line = span_info.1;
    let mut max_line = span_info.3;

    for block in &body.blocks {
        for stmt in &block.statements {
            if let Some(span_info) = span_index.get(&stmt.span.to_index()) {
                if span_info.0 == *file {
                    min_line = min_line.min(span_info.1);
                    max_line = max_line.max(span_info.3);
                }
            }
        }
        if let Some(span_info) = span_index.get(&block.terminator.span.to_index()) {
            if span_info.0 == *file {
                min_line = min_line.min(span_info.1);
                max_line = max_line.max(span_info.3);
            }
        }
    }

    let source = std::fs::read_to_string(file).ok()?;
    let lines: Vec<&str> = source.lines().collect();

    if min_line > 0 && max_line <= lines.len() {
        let extracted: Vec<&str> = lines[min_line - 1..max_line].to_vec();
        Some(extracted.join("\n"))
    } else {
        None
    }
}

/// Escape special Typst characters
fn escape_typst(s: &str) -> String {
    s.replace('\\', "\\\\")
        .replace('#', "\\#")
        .replace('$', "\\$")
        .replace('@', "\\@")
        .replace('<', "\\<")
        .replace('>', "\\>")
        .replace('[', "\\[")
        .replace(']', "\\]")
        .replace('_', "\\_")
        .replace('*', "\\*")
}
